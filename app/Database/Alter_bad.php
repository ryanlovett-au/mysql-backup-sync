<?php

namespace App\Database;

// Generated by Google Gemini 2.0 Flash

class Alter
{
    /**
     * Compares two MySQL table structures and generates ALTER TABLE statements.
     *
     * @param string $create_table1 The output of the first SHOW CREATE TABLE command.
     * @param string $create_table2 The output of the second SHOW CREATE TABLE command.
     * @param string $table_name    The name of the table (for the ALTER TABLE statements).
     * If not provided, it will be extracted from $create_table1.
     *
     * @return string The ALTER TABLE statements, or an empty string if the tables are identical.
     * Returns an error message string if an error occurs.
     */
    public static function compare_table_structures(string $create_table1, string $create_table2, string $table_name = ''): string
    {
        // Error handling: Check for empty input
        if (empty($create_table1) || empty($create_table2)) {
            return "Error: Both \$create_table1 and \$create_table2 must be provided.";
        }

        // Extract the table name if not provided
        if (empty($table_name)) {
            if (preg_match("/CREATE TABLE `([^`]+)`/", $create_table1, $matches)) {
                $table_name = $matches[1];
            } else {
                return "Error: Table name could not be extracted from \$create_table1.  Please provide the \$table_name parameter.";
            }
        }

        // Parse the CREATE TABLE statements
        $table1_structure = self::parse_create_table($create_table1);
        $table2_structure = self::parse_create_table($create_table2);

        if (is_string($table1_structure) || is_string($table2_structure)) {
            return "Error: Could not parse table structure.  Details: " . (is_string($table1_structure) ? $table1_structure : $table2_structure);
        }

        // Compare columns
        $alter_statements = self::compare_columns($table_name, $table1_structure['columns'], $table2_structure['columns']);

        // Compare indexes (primary, unique, index)
        $alter_statements .= self::compare_indexes($table_name, $table1_structure['indexes'], $table2_structure['indexes']);

        // Compare foreign keys
        $alter_statements .= self::compare_foreign_keys($table_name, $table1_structure['foreignKeys'], $table2_structure['foreignKeys']);

        // Compare table options (engine, charset, collate, etc.)
        $alter_statements .= self::compare_table_options($table_name, $table1_structure['options'], $table2_structure['options']);

        return $alter_statements;
    }

    /**
     * Parses a CREATE TABLE statement into an array of its components.
     *
     * @param string $create_table The CREATE TABLE statement.
     *
     * @return array An array containing the table structure, or a string error message on failure.
     * [
     * 'columns' => [
     * 'column_name' => [
     * 'type'     => 'data_type',
     * 'nullable' => bool,
     * 'default'  => 'default_value',
     * 'extra'    => 'auto_increment', // Example
     * 'comment'  => 'Column Comment'
     * ],
     * ...
     * ],
     * 'indexes' => [
     * 'index_name' => [
     * 'type'    => 'PRIMARY KEY | UNIQUE | INDEX | FULLTEXT | SPATIAL',
     * 'columns' => ['column1', 'column2', ...],
     * 'options' => 'USING BTREE', // Example
     * ],
     * ...
     * ],
     * 'foreignKeys' => [
     * 'constraint_name' => [
     * 'column'       => 'column_name',
     * 'referenced_table'   => 'referenced_table_name',
     * 'referenced_column'  => 'referenced_column_name',
     * 'on_delete'    => 'CASCADE | SET NULL | NO ACTION | RESTRICT | SET DEFAULT',
     * 'on_update'    => 'CASCADE | SET NULL | NO ACTION | RESTRICT | SET DEFAULT',
     * ],
     * ...
     * ],
     * 'options' => [
     * 'ENGINE'   => 'InnoDB',
     * 'CHARSET'  => 'utf8mb4',
     * 'COLLATE'  => 'utf8mb4_unicode_ci',
     * 'AUTO_INCREMENT' => 1,
     * 'COMMENT'  => 'Table Comment'
     * ...
     * ],
     * ]
     */
    private static function parse_create_table(string $create_table): array|string
    {
        $lines = preg_split("/\r\n|\n|\r/", $create_table); // Split into lines
        $table_name = '';
        $columns = [];
        $indexes = [];
        $foreign_keys = [];
        $options = [];
        $parsing_columns = false;

        foreach ($lines as $line) {
            $line = trim($line);

            // Skip empty lines and comments
            if (empty($line) || str_starts_with($line, '/*')) {
                continue;
            }

            // Extract table name
            if (preg_match("/CREATE TABLE `([^`]+)`/", $line, $matches)) {
                $table_name = $matches[1];
                $parsing_columns = true; // Start parsing column definitions
                continue;
            }

            if (!$parsing_columns) continue;

            // Stop parsing columns at the end.
            if (str_starts_with($line, ')') ) {
                $parsing_columns = false;
                continue;
            }


            // Parse column definitions
            if (preg_match("/`([^`]+)` (.*?),?$/", $line, $matches)) {
                $column_name = $matches[1];
                $column_details = $matches[2];

                $columns[$column_name] = self::parse_column_details($column_details);
                if (is_string($columns[$column_name])) {
                    return $columns[$column_name]; // Return the error message
                }
                continue;
            }

            // Parse primary key
            if (preg_match("/PRIMARY KEY \(([^)]+)\)/", $line, $matches)) {
                $index_columns = array_map(function ($c) { return trim(str_replace('`', '', $c)); }, explode(',', $matches[1]));
                $indexes['PRIMARY'] = [ // Use 'PRIMARY' as the key for the primary key
                    'type' => 'PRIMARY KEY',
                    'columns' => $index_columns,
                    'name' => 'PRIMARY' // Add a name for consistency
                ];
                continue;
            }

            // Parse unique key
            if (preg_match("/UNIQUE KEY `([^`]+)` \(([^)]+)\)/", $line, $matches)) {
                $index_name = $matches[1];
                $index_columns = array_map(function ($c) { return trim(str_replace('`', '', $c)); }, explode(',', $matches[2]));
                $indexes[$index_name] = [
                    'type' => 'UNIQUE',
                    'columns' => $index_columns,
                    'name' => $index_name
                ];
                continue;
            }
            // Parse index key
            if (preg_match("/KEY `([^`]+)` \(([^)]+)\)/", $line, $matches)) {
                $index_name = $matches[1];
                $index_columns = array_map(function ($c) { return trim(str_replace('`', '', $c)); }, explode(',', $matches[2]));
                 $indexes[$index_name] = [
                    'type' => 'INDEX',
                    'columns' => $index_columns,
                    'name' => $index_name
                ];
                continue;
            }

            // Parse fulltext index
            if (preg_match("/FULLTEXT KEY `([^`]+)` \(([^)]+)\)/", $line, $matches)) {
                $index_name = $matches[1];
                $index_columns = array_map(function ($c) { return trim(str_replace('`', '', $c)); }, explode(',', $matches[2]));
                $indexes[$index_name] = [
                    'type' => 'FULLTEXT',
                    'columns' => $index_columns,
                    'name' => $index_name
                ];
                continue;
            }

            // Parse foreign key constraints
            if (preg_match("/CONSTRAINT `([^`]+)` FOREIGN KEY \(`([^`]+)`\) REFERENCES `([^`]+)` \(`([^`]+)`\)(.*)/", $line, $matches)) {
                $constraint_name = $matches[1];
                $column_name = $matches[2];
                $referenced_table = $matches[3];
                $referenced_column = $matches[4];
                $rest_of_line = $matches[5];

                $foreign_keys[$constraint_name] = [
                    'column'            => $column_name,
                    'referenced_table'  => $referenced_table,
                    'referenced_column' => $referenced_column,
                    'on_delete'         => 'NO ACTION',
                    'on_update'         => 'NO ACTION',
                ];

                // Parse ON DELETE and ON UPDATE actions
                if (strpos($rest_of_line, 'ON DELETE') !== false) {
                    if (preg_match("/ON DELETE (CASCADE|SET NULL|NO ACTION|RESTRICT|SET DEFAULT)/", $rest_of_line, $action_match)) {
                        $foreign_keys[$constraint_name]['on_delete'] = $action_match[1];
                    }
                }
                if (strpos($rest_of_line, 'ON UPDATE') !== false) {
                    if (preg_match("/ON UPDATE (CASCADE|SET NULL|NO ACTION|RESTRICT|SET DEFAULT)/", $rest_of_line, $action_match)) {
                        $foreign_keys[$constraint_name]['on_update'] = $action_match[1];
                    }
                }
                continue;
            }

            // Parse table options (ENGINE, CHARSET, COLLATE, etc.)
            if (preg_match("/(ENGINE|DEFAULT CHARSET|COLLATE|AUTO_INCREMENT|COMMENT)=(.*?)( |$)/i", $line, $matches)) {
                $option_name = strtoupper(trim($matches[1])); // Use strtoupper for consistency
                $option_value = trim(str_replace(['=', ';', ','], '', $matches[2]));
                $options[$option_name] = $option_value;
                continue;
            }
        }
        return [
            'columns'     => $columns,
            'indexes'     => $indexes,
            'foreignKeys' => $foreign_keys,
            'options'     => $options,
        ];
    }

    /**
     * Parses the column definition string from a CREATE TABLE statement.
     *
     * @param string $column_details The column definition string (e.g., "INT NOT NULL AUTO_INCREMENT").
     *
     * @return array An array containing the column details, or a string error message on failure.
     * [
     * 'type'     => 'INT',
     * 'nullable' => false,
     * 'default'  => null,
     * 'extra'    => 'AUTO_INCREMENT',
     * 'comment'  => 'Column Comment'
     * ]
     */
    private static function parse_column_details(string $column_details): array|string
    {
        $details = [];
        $parts = explode(' ', $column_details);
        $parts = array_map('trim', $parts); //important

        $type = '';
        $nullable = true;
        $default = null;
        $extra = '';
        $comment = '';

        foreach ($parts as $part) {
            $part = trim($part);
            if (empty($part)) continue;

            $part_upper = strtoupper($part); //for comparison

            // Data type (e.g., INT, VARCHAR(255), DATE)
            if (preg_match("/^[A-Za-z]+(\(\d+(,\s*\d+)?\))?$/", $part)) {
                $type = $part;
            } elseif ($part_upper === 'NOT') {
                $nullable = false;
            } elseif ($part_upper === 'NULL') {
                $nullable = true; //explicitly set to true
            } elseif ($part_upper === 'DEFAULT') {
                // Handle default values, including quoted strings
                $default = '';
                $next_part_index = array_search($part, $parts) + 1;
                if ($next_part_index < count($parts)) {
                     $next_part = $parts[$next_part_index];
                    if (str_starts_with($next_part, "'") || str_starts_with($next_part, '"')) {
                        //grab until the ending quote.
                        $quote_char = $next_part[0];
                        $default .= $next_part;
                        $next_part_index++;
                        while ($next_part_index < count($parts)) {
                            $next_part = $parts[$next_part_index];
                             $default .= ' ' . $next_part;
                            if (str_ends_with($next_part, $quote_char))
                                break;
                            $next_part_index++;
                        }
                    }
                    else {
                        $default = $parts[$next_part_index];
                    }
                }
            } elseif ($part_upper === 'AUTO_INCREMENT') {
                $extra = 'AUTO_INCREMENT';
            }  elseif ($part_upper === 'COMMENT') {
                 $comment = '';
                 $next_part_index = array_search($part, $parts) + 1;
                  if ($next_part_index < count($parts)) {
                     $comment = $parts[$next_part_index];
                     //grab until the ending quote
                      $quote_char = $comment[0];
                      $next_part_index++;
                      while ($next_part_index < count($parts)) {
                          $next_part = $parts[$next_part_index];
                          $comment .= ' ' . $next_part;
                          if (str_ends_with($next_part, $quote_char))
                              break;
                          $next_part_index++;
                      }
                  }
            }
            //ignore UNSIGNED and other modifiers

        }

        return [
            'type'     => $type,
            'nullable' => $nullable,
            'default'  => $default,
            'extra'    => $extra,
            'comment'  => trim(str_replace("'",'', $comment)), //remove quotes
        ];
    }

    /**
     * Compares two arrays of column definitions and generates ALTER TABLE statements.
     *
     * @param string $table_name The name of the table.
     * @param array  $columns1   The column definitions from the first table.
     * @param array  $columns2   The column definitions from the second table.
     *
     * @return string The ALTER TABLE statements for column differences.
     */
    private static function compare_columns(string $table_name, array $columns1, array $columns2): string
    {
        $alter_statements = '';
        $existing_columns = array_keys($columns1);
        $new_columns = array_keys($columns2);

        // Check for new columns in table2
        foreach ($new_columns as $column_name) {
            if (!in_array($column_name, $existing_columns)) {
                $alter_statements .= "ALTER TABLE `$table_name` ADD COLUMN `$column_name` " . self::column_definition_to_string($columns2[$column_name]) . ";\n";
            }
        }

        // Check for dropped or modified columns
        foreach ($columns1 as $column_name => $column_definition) {
            if (!isset($columns2[$column_name])) {
                $alter_statements .= "ALTER TABLE `$table_name` DROP COLUMN `$column_name`;\n";
            } else {
                // Compare column definitions
                if (self::column_definition_to_string($column_definition) !== self::column_definition_to_string($columns2[$column_name])) {
                    $alter_statements .= "ALTER TABLE `$table_name` MODIFY COLUMN `$column_name` " . self::column_definition_to_string($columns2[$column_name]) . ";\n";
                }
            }
        }
        return $alter_statements;
    }

    /**
     * Converts a column definition array to a string.
     *
     * @param array $column_definition The column definition array.
     *
     * @return string The column definition string.
     */
    private static function column_definition_to_string(array $column_definition): string
    {
        $definition = "`{$column_definition['type']}`";
        $definition .= $column_definition['nullable'] ? ' NULL' : ' NOT NULL';
        if ($column_definition['default'] !== null) {
            if (is_string($column_definition['default']))
               $definition .= " DEFAULT '{$column_definition['default']}'";
            else
                $definition .= " DEFAULT {$column_definition['default']}";
        }
        $definition .= ' ' . $column_definition['extra'];
        if (!empty($column_definition['comment'])) {
            $definition .= " COMMENT '{$column_definition['comment']}'";
        }
        return trim($definition);
    }

    /**
     * Compares two arrays of index definitions and generates ALTER TABLE statements.
     *
     * @param string $table_name The name of the table.
     * @param array  $indexes1   The index definitions from the first table.
     * @param array  $indexes2   The index definitions from the second table.
     *
     * @return string The ALTER TABLE statements for index differences.
     */
    private static function compare_indexes(string $table_name, array $indexes1, array $indexes2): string
    {
        $alter_statements = '';

        // Drop indexes that exist in table1 but not in table2
        foreach ($indexes1 as $index_name => $index_definition) {
            if (!isset($indexes2[$index_name])) {
                if ($index_name === 'PRIMARY') {
                    $alter_statements .= "ALTER TABLE `$table_name` DROP PRIMARY KEY;\n";
                } else {
                    $alter_statements .= "ALTER TABLE `$table_name` DROP INDEX `$index_name`;\n";
                }
            }
        }

        // Add or modify indexes
        foreach ($indexes2 as $index_name => $index_definition) {
            if (!isset($indexes1[$index_name])) {
                 $alter_statements .= "ALTER TABLE `$table_name` ADD " . self::local_index_definition_to_string($index_definition) . ";\n";
            }
            else {
                //check if definition is different.
                if (self::local_index_definition_to_string($indexes1[$index_name])  !== self::local_index_definition_to_string($index_definition)) {
                     //drop the old and create the new.
                    if ($index_name === 'PRIMARY') {
                        $alter_statements .= "ALTER TABLE `$table_name` DROP PRIMARY KEY;\n";
                    } else {
                        $alter_statements .= "ALTER TABLE `$table_name` DROP INDEX `$index_name`;\n";
                    }
                    $alter_statements .= "ALTER TABLE `$table_name` ADD " . self::local_index_definition_to_string($index_definition) . ";\n";
                }
            }
        }
        return $alter_statements;
    }

    private static function local_index_definition_to_string(array $index_definition) : string 
    {
        $index_string = strtoupper($index_definition['type']) . ' ';
        if (isset($index_definition['name']) && $index_definition['name'] !== 'PRIMARY')
            $index_string .=  "`{$index_definition['name']}` ";
        $index_string .=  '(' . implode(',', array_map(function($c){ return "`$c`";}, $index_definition['columns'])) . ')';
        if (isset($index_definition['options']))
            $index_string .= ' ' . $index_definition['options'];
        return trim($index_string);
    }

    /**
     * Compares two arrays of foreign key definitions and generates ALTER TABLE statements.
     *
     * @param string $table_name    The name of the table.
     * @param array  $foreign_keys1 The foreign key definitions from the first table.
     * @param array  $foreign_keys2 The foreign key definitions from the second table.
     *
     * @return string The ALTER TABLE statements for foreign key differences.
     */
    private static function compare_foreign_keys(string $table_name, array $foreign_keys1, array $foreign_keys2): string
    {
        $alter_statements = '';

        // Drop foreign keys that exist in table1 but not in table2
        foreach ($foreign_keys1 as $constraint_name => $fk_definition) {
            if (!isset($foreign_keys2[$constraint_name])) {
                $alter_statements .= "ALTER TABLE `$table_name` DROP FOREIGN KEY `$constraint_name`;\n";
            }
        }

        // Add or modify foreign keys
        foreach ($foreign_keys2 as $constraint_name => $fk_definition) {
            if (!isset($foreign_keys1[$constraint_name])) {
                $alter_statements .= self::generate_add_foreign_key_statement($table_name, $constraint_name, $fk_definition);
            } else {
                // Compare foreign key definitions
                if (self::foreign_key_definition_to_string($fk_definition) !== self::foreign_key_definition_to_string($foreign_keys1[$constraint_name])) {
                    // Drop the old foreign key and add the new one
                    $alter_statements .= "ALTER TABLE `$table_name` DROP FOREIGN KEY `$constraint_name`;\n";
                    $alter_statements .= self::generate_add_foreign_key_statement($table_name, $constraint_name, $fk_definition);
                }
            }
        }
        return $alter_statements;
    }

      /**
      * Converts a foreign key definition array to a string
      *
      * @param array $fk_definition
      * @return string
      */
    private static function foreign_key_definition_to_string(array $fk_definition) : string {
        $fk_string = "`{$fk_definition['column']}` REFERENCES `{$fk_definition['referenced_table']}` (`{$fk_definition['referenced_column']}`)";
        $fk_string .= " ON DELETE {$fk_definition['on_delete']} ON UPDATE {$fk_definition['on_update']}";
        return $fk_string;
    }

    /**
     * Generates an ALTER TABLE statement to add a foreign key.
     *
     * @param string $table_name      The name of the table.
     * @param string $constraint_name The name of the foreign key constraint.
     * @param array  $fk_definition   The foreign key definition array.
     *
     * @return string The ALTER TABLE statement.
     */
    private static function generate_add_foreign_key_statement(string $table_name, string $constraint_name, array $fk_definition): string
    {
        $statement = "ALTER TABLE `$table_name` ADD CONSTRAINT `$constraint_name` FOREIGN KEY (`{$fk_definition['column']}`) REFERENCES `{$fk_definition['referenced_table']}` (`{$fk_definition['referenced_column']}`)";
        $statement .= " ON DELETE {$fk_definition['on_delete']} ON UPDATE {$fk_definition['on_update']}";
        $statement .= ";\n";
        return $statement;
    }

    /**
     * Compares two arrays of table options and generates ALTER TABLE statements.
     *
     * @param string $table_name The name of the table.
     * @param array  $options1   The table options from the first table.
     * @param array  $options2   The table options from the second table.
     *
     * @return string The ALTER TABLE statements for table option differences.
     */
    private static function compare_table_options(string $table_name, array $options1, array $options2): string
    {
        $alter_statements = '';

        foreach ($options2 as $option_name => $option_value) {
            if (!isset($options1[$option_name]) || $options1[$option_name] != $option_value) {
                $alter_statements .= "ALTER TABLE `$table_name` " . self::get_alter_table_option_statement($option_name, $option_value) . ";\n";
            }
        }
        return $alter_statements;
    }

    /**
     * Generates the part of an ALTER TABLE statement for a specific table option.
     *
     * @param string $option_name  The name of the table option (e.g., 'ENGINE', 'CHARSET').
     * @param string $option_value The value of the table option.
     *
     * @return string The part of the ALTER TABLE statement.
     */
    private static function get_alter_table_option_statement(string $option_name, string $option_value): string
    {
        $option_name = strtolower($option_name); //make case-insensitive
        if ($option_name === 'engine') {
            return "ENGINE=$option_value";
        } elseif ($option_name === 'default charset') {
            return "DEFAULT CHARACTER SET=$option_value";
        } elseif ($option_name === 'charset') {
            return "CHARACTER SET=$option_value";
        } elseif ($option_name === 'collate') {
            return "COLLATE=$option_value";
        } elseif ($option_name === 'auto_increment') {
            return "AUTO_INCREMENT=$option_value";
        } elseif ($option_name === 'comment') {
            return "COMMENT '$option_value'";
        }
        return ''; // Return empty string for unknown options
    }
}

?>
